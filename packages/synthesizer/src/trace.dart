/*
 * TunePad
 *
 * Michael S. Horn
 * Northwestern University
 * michael-horn@northwestern.edu
 * Copyright 2020, Michael S. Horn
 *
 * This project was funded by the National Science Foundation (grant DRL-1612619).
 * Any opinions, findings and conclusions or recommendations expressed in this
 * material are those of the author(s) and do not necessarily reflect the views
 * of the National Science Foundation (NSF).
 */
import 'dart:math';
import 'dart:convert';

import 'note.dart';
import 'utils.dart';

/**
 * A Trace object is generated by the python compiler and represents a list of 
 * audio / visual events that generate sounds and animation.
 */
class Trace {

  /// a trace is just a list of events
  List<TraceEvent> trace = new List<TraceEvent>();

  /// number of events in the trace
  int get length => trace.length;

  /// keeps track of the current trace location for animation or stepping through code
  int bug = 0;

  /// keeps track of timing for print statements from python
  num _timer = 0;

  /// is this trace empty
  bool get isEmpty => trace.isEmpty;

  /// number of beats in the trace (to the end of the last note)
  num _beats = 0;
  num get beats => _beats;

  /// what's the minimum note value in this trace (or -1 if there are no notes)
  num _minNote = -1;
  num get minNote => _minNote;

  /// what's the maximum note value in this trace (or -1 if there are no notes)
  num _maxNote = -1;
  num get maxNote => _maxNote;

  /// return the trace event at the given index
  TraceEvent operator[](int index) => trace[index];



  Trace() { }


  void clear() {
    trace.clear();
    bug = 0;
    _timer = 0;
    _beats = 0;
    _minNote = -1;
    _maxNote = -1;
  }


/**
 * Restart a step-by-step walkthrough of this trace
 */
  void restart() {
    bug = 0;
  }


/**
 * Get the current event in a step-by-step walkthrough of this trace
 */
  TraceEvent current() {
    return (bug >= 0 && bug < trace.length) ? trace[bug] : null;
  }


/**
 * Advance to the next event in the trace
 */
  TraceEvent advance() {
    if (bug < trace.length) bug++;
    return current();
  }


/**
 * Fastforward to the given event in a step-by-step walkthrough
 */
  TraceEvent advanceToEvent(TraceEvent t) {
    for (int i=0; i<trace.length; i++) {
      if (trace[i] == t) {
        bug = i;
        return trace[i];
      }
    }
    bug = 0;
    return null;
  }

/**
 * Fastforward to the given beat
 */
  TraceEvent advanceToBeat(num beats) {
    TraceEvent target = null;
    for (TraceEvent t in trace) {
      if (t.command == TraceEvent.TRACE) {
        if (t.time <= beats) {
          if (target == null || t.time > target.time) target = t;
        }
      }
    }
    return advanceToEvent(target);
  }


/**
 * Have we finished the walkthrough?
 */
  bool get isDone => (bug >= trace.length);


/**
 * Add an event to the trace
 */
  void addEvent(String jsonString) {
    TraceEvent event = null;
    try {
      Map json = jsonDecode(jsonString);
      event = new TraceEvent.fromJSON(json);
      trace.add(event);
      if (event.command == TraceEvent.TRACE) {
        _timer = event.time;
      }
      else if (event.command == TraceEvent.PLAY) {
        _beats = max(event.time + event.duration, _beats);
        if (_minNote < 0 || event.note.note < _minNote) _minNote = event.note.note;
        _maxNote = max(_maxNote, event.note.note);
      }
    } catch (exception) {
      print('error decoding trace event: ' + jsonString);
    }
  }


/**
 * Add a python "print" output statement to the trace
 */
  void addPrint(String output) {
    trace.add(
      new TraceEvent(TraceEvent.PRINT, _timer)
        .. duration = 1
        .. params['output'] = output
    );
  }


  List toJSON() {
    var json = [];
    for (TraceEvent t in trace) json.add(t.toJSON());
    return json;
  }


  void fromJSON(var json) {
    clear();
    if (json is List) {
      for (var t in json) {
        trace.add(new TraceEvent.fromJSON(t));
      }
    }
  }
}


/**
 * Visual / audio trace of a program's execution. Trace events are generated by 
 * python and then replayed to generate sounds and animation. 
 */ 
class TraceEvent {

  static final String TRACE = "trace";         /// trace a line of code or block 
  static final String PLAY = "play";           /// command code to play a note
  static final String PRINT = "print";         /// print a value to the console
  static final String REST = "rest";           /// rest for an interval
  static final String START = "start";         /// mark the start of a loop
  static final String STOP = "stop";           /// mark the end of a loop
  static final String VOICE = "voice";         /// change the instrument voice
  static final String COLOR = "color";         /// change the color of a puck
  static final String PUSH_FX = "push_fx";     /// push an audio effect
  static final String POP_FX = "pop_fx";       /// pop the audio effect stack
  static final String PATCH = "patch";         /// changes the synthesizer patch configuration
  

  /// name of the trace event
  String command = null;

  /// start time of the event in beats
  num time = 0;

  /// duration of the event in beats
  num duration = 1;

  /// end time of the event in beats
  num get end => time + duration;

  /// variable parameters
  Map<String, dynamic> params = new Map<String, dynamic>();

  /// note to play (shortcut for play event)
  Note get note => (params["note"] as Note);

  dynamic operator[](String key) => params[key];

  void operator[]=(String key, var value) { params[key] = value; }

  bool hasParam(String key) => params.containsKey(key);



  TraceEvent(this.command, this.time);


  TraceEvent clone() {
    TraceEvent t = new TraceEvent(command, time);
    for (String key in params.keys) {
      t[key] = params[key];
    }
    return t;
  }


  TraceEvent.fromJSON(Map json) {
    this.command = toStr(json['command']);
    this.time = toNum(json['time'], 0);
    this.duration = toNum(json['duration'], 1);
    Note note = null;
    if (json['params'] is Map) {
      for (String key in json['params'].keys) {
        if (key == "note") {
          note = new Note(toNum(json['params'][key], 60));
          note.duration = duration;
          params[key] = note;
        } else {
          params[key] = json['params'][key];
        }
      }
    }
    if (note != null && params.containsKey('velocity')) {
      note.velocity = toInt(params['velocity'], 100);
    }
    if (note != null && params.containsKey('sustain')) {
      num sustain = toNum(params['sustain'], 0);
      note.duration = max(note.duration, sustain);
      this.duration = note.duration;
    }
  }


  Map toJSON() {
    Map<String, dynamic> json = {
      "command" : command,
      "time" : time,
      "duration" : duration,
      "params" : { }
    };

    for (String key in params.keys) {
      if (key == "note") {
        (json["params"] as Map)[key] = note.note;
      } else {
        (json["params"] as Map)[key] = params[key];
      }
    }
    return json;
  }
}

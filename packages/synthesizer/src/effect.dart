/*
 * TunePad
 *
 * Michael S. Horn
 * Northwestern University
 * michael-horn@northwestern.edu
 * Copyright 2020, Michael S. Horn
 *
 * This project was funded by the National Science Foundation (grant DRL-1612619).
 * Any opinions, findings and conclusions or recommendations expressed in this
 * material are those of the author(s) and do not necessarily reflect the views
 * of the National Science Foundation (NSF).
 */
import 'dart:math';
import 'dart:web_audio';

import 'event.dart';
import 'utils.dart';


/// Audio effects can be added to a synthesizer's fx "stack".
/// Some effects get layered together in the audio chain.
/// Other effects (after effects) are applied on top of existing
/// SynthesizerEvents after the chain is constructed.
abstract class Effect {

  /// name of the effect
  String name;

  /// array of parameter values applied dynamically to the effect
  List<List<num>> params = new List<List<num>>();

  /// delayed start time of the pitch bend effect in beats (0 means now)
  num start = 0;

  /// duration of the pitch bend in beats. a negative value indicates that this
  /// effect is constant (no dynamic changes over time)
  num beats = -1.0;

  /// node that gets inserted into the effects chain
  AudioNode node = null;

  /// original list of params generated by the python code
  Map<String, dynamic> oparams;


  factory Effect(String name, Map<String, dynamic> params) {
    if (name == "lowpass" || name == "filter") {
      return new BiquadFilter("lowpass", params);
    } else if (name == "highpass") {
      return new BiquadFilter("highpass", params);
    } else if (name == "bandpass") {
      return new BiquadFilter("bandpass", params);
    } else if (name == "notch") {
      return new BiquadFilter("notch", params);
    } else if (name == "pan") {
      return new PanEffect(params);
    } else if (name == "gain") {
      return new GainEffect(params);
    } else if (name == "bend") {
      return new PitchBendEffect(params);
    } else {
      return null;
    }
  }


  Effect._internal(this.name, Map<String, dynamic> params) {
    this.start = max(0, toNum(params['start']));
    this.beats = toNum(params['beats']);
    this.oparams = params;
    for (var c in params['values']) {
      List<num> values = new List<num>();
      if (c is List) {
        for (var val in c) values.add(toNum(val));
      }
      else if (c is num) {
        values.add(c);
      }
      this.params.add(values);
    }
  }


  Effect clone() {
    return new Effect(this.name, this.oparams);
  }


  /// connect this effect to the destination node. returns the source
  /// audio node for this effect.
  /// subclasses must override. by default this is just a bypass
  AudioNode connect(AudioNode dest, int bpm, num delay, num offset) {
    node = dest.context.createGain() .. gain.value = 1.0;
    node.connectNode(dest);
    return node;
  }


  /// disconnect and dispose of the audio nodes used in this effect
  void disconnect() {
    if (node != null) node.disconnect();
    node = null;
  }


  /// override to apply after effects to notes
  void afterEffect(SynthEvent event, int bpm, num delay, num offset) { }


  /// clamp all of the parameter values within a range
  void clampParam(List<num> param, num minVal, num maxVal) {
    for (int i=0; i<param.length; i++) {
      param[i] = param[i].clamp(minVal, maxVal);
    }
  }
}


/// Standard lowpass filter. Recognizes a frequency 
/// parameter, a "Q"uality parameter, and a gain parameter
class BiquadFilter extends Effect {

  /// filter type (e.g. "lowpass", "highpass", "bandpass", "notch")
  String type = "lowpass";

  List<num> get frequency => this.params[0];

  List<num> get Q => this.params[1];

  List<num> get gain => this.params[2];


  BiquadFilter(String name, Map<String, dynamic> params) : super._internal(name, params) {
    this.type = name;

    if (this.params.isEmpty) {
      this.params.add(new List<num>());
      this.frequency.add(1000);
    }

    if (this.params.length < 2) {
      this.params.add(new List<num>());
      this.Q.add(0.8);
    }

    if (this.params.length < 3) {
      this.params.add(new List<num>());
      this.gain.add(1.0);
    }

    clampParam(frequency, 10, 22050);
    if (name == "highpass" || name == "lowpass") clampParam(Q, -20.0, 20.0);
  }


  AudioNode connect(AudioNode dest, int bpm, num delay, num offset) {
    node = dest.context.createBiquadFilter() .. type = this.type;
    node.connectNode(dest);

    AudioParam fp = (node as BiquadFilterNode).frequency;
    AudioParam qp = (node as BiquadFilterNode).Q;
    AudioParam gp = (node as BiquadFilterNode).gain;

    num when = dest.context.currentTime + delay + start * (60 / bpm) - offset;

    fp.value = frequency[0];
    qp.value = Q[0];
    gp.value = gain[0];

    if (beats > 0 && frequency.length > 1) {
      fp.cancelScheduledValues(0);
      fp.setValueCurveAtTime(frequency, when, beats * (60 / bpm));
    }

    if (beats > 0 && Q.length > 1) {
      qp.cancelScheduledValues(0);
      qp.setValueCurveAtTime(Q, when, beats * (60 / bpm));
    }

    if (beats > 0 && gain.length > 1) {
      gp.cancelScheduledValues(0);
      gp.setValueCurveAtTime(gain, when, beats * (60 / bpm));
    }

    return node;
  }
}


/// Pitch bend effect
class PitchBendEffect extends Effect {

  List<num> get values => this.params[0];

  PitchBendEffect(Map<String, dynamic> params) : super._internal("bend", params);

  /// pitch bend is applied to notes after they have been scheduled to play
  void afterEffect(SynthEvent event, int bpm, num delay, num offset) {
    if (values.isEmpty) return;

    if (beats <= 0) {
      event.pitchBend(values[0]);
    } else {
      if (values.length == 1) values.insert(0, 0.0);
      num when = delay + start * (60 / bpm) - offset;
      event.schedulePitchBend(max(0, when), beats * (60 / bpm), values);
    }
  }
}


class PanEffect extends Effect {

  List<num> get values => this.params[0];


  PanEffect(Map<String, dynamic> params) : super._internal("pan", params) {
    clampParam(values, -1.0, 1.0);
  }


  AudioNode connect(AudioNode dest, int bpm, num delay, num offset) {
    node = dest.context.createStereoPanner();
    node.connectNode(dest);

    AudioParam p = (node as StereoPannerNode).pan;

    if (values.isEmpty) return node;

    p.value = values[0];

    if (beats > 0 && values.length > 1) {
      num when = dest.context.currentTime + delay + start * (60 / bpm) - offset;
      p.cancelScheduledValues(0);
      p.setValueCurveAtTime(values, when, beats * (60 / bpm));
    }
    return node;
  }
}


class GainEffect extends Effect {

  List<num> get values => this.params[0];

  GainEffect(Map<String, dynamic> params) : super._internal("gain", params);


  AudioNode connect(AudioNode dest, int bpm, num delay, num offset) {
    node = dest.context.createGain();
    node.connectNode(dest);

    AudioParam param = (node as GainNode).gain;

    if (values.isEmpty) return node;

    param.value = values[0];

    if (beats > 0 && values.length > 1) {
      num when = dest.context.currentTime + delay + start * (60 / bpm) - offset;
      param.cancelScheduledValues(0);
      param.setValueCurveAtTime(values, when, beats * (60 / bpm));
    }
    return node;
  }
}

